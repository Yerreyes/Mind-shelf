"use server";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();
// This function does not receive the previous state (...prevState) because it is not utilizing the useFormState hook, which is typically used for managing form state in React.

async function helperTransformData(formData) {
  const image = formData.get("image");

  if (image) {
    const buffer = await image.arrayBuffer();
    const base64Image = Buffer.from(buffer).toString("base64");
    formData.set("image", base64Image);
  }

  const transformed = {
    category: formData.get("category"),
    title: formData.get("title"),
    fields: {},
  };

  formData.delete("category");
  formData.delete("title");
  for (const [key, value] of formData.entries()) {
    //that sentence avoids to store the autoId generated by next js form
    if (!key.startsWith("$ACTION_ID_")) {
      transformed.fields[key] = value;
    }
  }
  return transformed;
}

export async function saveDataAction(_, formData) {
  try {
    const data = await helperTransformData(formData);
    await prisma.module.create({
      data: data,
    });

    console.log(await getModules());
    return { success: true, message: "Se añadió correctamente" };
  } catch (error) {
    return { success: false, message: "Ocurrió un error" };
  }
}

export async function getModules() {
  try {
    return await prisma.module.findMany();
  } catch (error) {
    console.error("Error fetching modules:", error);
    throw new Error("Failed to fetch modules. Please try again later.");
  }
}

export async function getModulesByCategory(category) {
  const modules = await prisma.module.findMany({
    where: { category: category },
  });
  return modules;
}

export async function getModule(id){
  const module = await prisma.module.findFirst({
    where: { id: id },
  });
  console.log(module);
  return module;
}